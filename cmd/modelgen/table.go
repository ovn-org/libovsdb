package main

import (
	"fmt"
	"sort"
	"strings"
	"text/template"

	"github.com/ovn-org/libovsdb/ovsdb"
)

const TABLE_TEMPLATE = `
// Code generated by "ovsdb.modelgen"
// DO NOT EDIT.

package {{ .PackageName }}

// {{ .StructName }} defines an object in {{ .TableName }} table
type {{ .StructName }} struct {
    {{ range .Fields }} {{ .Name }}  {{ .Type }}   {{ .Tag }}
    {{ end }}
}
`

// TableTemplateData is the data needed for template processing
type TableTemplateData struct {
	TableName   string
	PackageName string
	StructName  string
	Fields      []Field
}

// Field represents the field information
type Field struct {
	Name string
	Type string
	Tag  string
}

// NewTableGenerator returns a table code generator
func NewTableGenerator(pkg string, name string, table *ovsdb.TableSchema) Generator {
	templateData := TableTemplateData{
		TableName:   name,
		PackageName: pkg,
		StructName:  StructName(name),
		Fields:      []Field{},
	}
	// First, add UUID
	templateData.Fields = append(templateData.Fields,
		Field{
			Name: "UUID",
			Type: "string",
			Tag:  Tag("_uuid"),
		})

	// Map iteration order is random, so for predictable generation
	// lets sort fields by name
	var order sort.StringSlice
	for columnName := range table.Columns {
		order = append(order, columnName)
	}
	order.Sort()

	for _, columnName := range order {
		columnSchema := table.Columns[columnName]
		templateData.Fields = append(templateData.Fields, Field{
			Name: FieldName(columnName),
			Type: FieldType(columnSchema),
			Tag:  Tag(columnName),
		})
	}

	tableTemplate := template.Must(template.New(name).Parse(TABLE_TEMPLATE))
	return newGenerator(FileName(name), tableTemplate, templateData)
}

// FieldName returns the name of a column field
func FieldName(column string) string {
	return camelCase(column)
}

// StructName returns the name of the table struct
func StructName(tableName string) string {
	return strings.ReplaceAll(tableName, "_", "")
}

// FieldType returns the string representation of a column type
func FieldType(column *ovsdb.ColumnSchema) string {
	switch column.Type {
	case ovsdb.TypeEnum:
		return AtomicType(column.TypeObj.Key.Type)
	case ovsdb.TypeMap:
		return fmt.Sprintf("map[%s]%s", AtomicType(column.TypeObj.Key.Type),
			AtomicType(column.TypeObj.Value.Type))
	case ovsdb.TypeSet:
		return fmt.Sprintf("[]%s", AtomicType(column.TypeObj.Key.Type))
	default:
		return AtomicType(column.Type)
	}
}

// BasicType returns the string type of an AtomicType
func AtomicType(atype string) string {
	switch atype {
	case ovsdb.TypeInteger:
		return "int"
	case ovsdb.TypeReal:
		return "float64"
	case ovsdb.TypeBoolean:
		return "bool"
	case ovsdb.TypeString:
		return "string"
	case ovsdb.TypeUUID:
		return "string"
	}
	return ""
}

// Tag returns the Tag string of a column
func Tag(column string) string {
	return fmt.Sprintf("`ovs:\"%s\"`", column)
}

// Filename returns the filename of a table
func FileName(table string) string {
	return fmt.Sprintf("%s.go", strings.ToLower(table))
}

// common initialisms used in ovsdb schemas
var initialisms = map[string]bool{
	"ACL":   true,
	"BFD":   true,
	"CFM":   true,
	"CT":    true,
	"CVLAN": true,
	"DNS":   true,
	"DSCP":  true,
	"ID":    true,
	"IP":    true,
	"IPFIX": true,
	"LACP":  true,
	"LLDP":  true,
	"MAC":   true,
	"MTU":   true,
	"OVS":   true,
	"QOS":   true,
	"RSTP":  true,
	"SSL":   true,
	"STP":   true,
	"TCP":   true,
	"UDP":   true,
	"UUID":  true,
	"VLAN":  true,
}

func camelCase(field string) string {
	s := strings.ToLower(field)
	parts := strings.FieldsFunc(s, func(r rune) bool {
		return r == '_' || r == '-'
	})
	if len(parts) > 1 {
		s = ""
		for _, p := range parts {
			s += strings.Title(expandInitilaisms(p))
		}
	} else {
		s = strings.Title(expandInitilaisms(s))
	}
	return s
}

func expandInitilaisms(s string) string {
	// check initialisms
	if u := strings.ToUpper(s); initialisms[u] {
		return strings.ToUpper(s)
	}
	// check for plurals too
	if strings.HasSuffix(s, "s") {
		sub := s[:len(s)-1]
		if u := strings.ToUpper(sub); initialisms[u] {
			return strings.ToUpper(sub) + "s"
		}
	}
	return s
}
